\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[left=12mm,
right=12mm,top=1.0in,
bottom=1.5in]{geometry}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{cancel}
\usepackage{graphicx}
\usepackage{grffile}
\graphicspath{{/home/piotr/Documents/scientific-computing/list04/exercise5/plots/}{/home/piotr/Documents/scientific-computing/list04/exercise6/plots/}}
\DeclareUnicodeCharacter{2212}{-}
\begin{document}
\title{{Obliczenia Naukowe}}
\author{Laboratorium Lista Nr 5\\Piotr Popis\\ 245162}
\date{6 grudzień 2019}
\maketitle
\centering

\begin{flushleft}
\section{Wstęp}
\subsection{Streszczenie}
Problemem jest rozwiązanie równania liniowego $Ax=b$,gdzie $A \epsilon R^{nxn}$ jest podaną macierzą, a $b \epsilon R^n$ zadanym wektorem prawych stron( przy założeniu, iż $n \geq 4$ ).
Dodatkowo macierz A jest macierzą rzadką- taką, która ma dużo elementów zerowych oraz blokową.
\[
A=\begin{bmatrix}
      A_1 & C_1 & 0 & ... & 0 \\
    B_2 & A_2 & C_2 & .. & 0 \\
    \vdots & \ddots & \ddots & \ddots & \vdots \\
     0 & ... & B_{v-1} & A_{v-1} & C_{v-1} \\
      0 & ... & 0 & B_v & A_v \\
  \end{bmatrix}
\]
, gdzie $v=\dfrac{n}{l}$ przy założeniu iż l zawsze dzieli n( n jest podzielne przez l) oraz $l\geq2$. l jest rozmiarem wszystkich kwadratowych macierzy wewnętrznych - bloków: $A_k, B_k, C_k$. Mianowicie: $$A_k \epsilon R^{lxl}, k = 1,...,v  ,$$ A jest macierzą gęstą, \\0 jest kwadratową macierzą zerową stopnia l,\\Natomiast macierz $$B_k \epsilon R^{lxl}, k = 2,...,v  ,$$ $B_k$ ma tylko \underline{dwie ostatnie kolumny niezerowe} i jest postaci:   
\[
B_k=\begin{bmatrix}
      0 & ... & 0 & b^k_{1l-1} & b^k_{1l} \\
      0 & ... & 0 & b^k_{2l-1} & b^k_{2l} \\
      \vdots &     & \vdots & \vdots & \vdots \\
      0 & ... & 0 & b^k_{ll-1} & b^k_{ll} \\
  \end{bmatrix}
\]
Ostani z bloków $$C_k \epsilon R^{lxl}, k = 1,...,v-1  ,$$ $C_k$ jest macierzą diagonalną i jest postaci:
\[
C_k=\begin{bmatrix}
      c^k_1 & 0 & 0 & ... & 0 \\
    0 & c^k_2 & 0 & .. & 0 \\
    \vdots & \ddots & \ddots & \ddots & \vdots \\
     0 & ... & 0 & c^k_{l-1} & 0 \\
      0 & ... & 0 & 0 & c^k_l \\
  \end{bmatrix}
\]
Z treści n jest ogromne co wiąże się dużym obciążeniem pamięciowym jak i czasowym w przypadku zwykłej tablicy. Należy skorzystać z pakietu SparseArrays, która zawiera specjalną strukturę efektywnie pamiętająca specyficznie macierze, tj rzadkość lub regularność występowania elementów zerowych i niezerowych. Istniejące algorytmy do rozwiązywania takich problemów trzeba po prostu zmodyfikować do użycia tej spejcalnej struktury. Jeśli l jest stałe Algorytmy da się zoptymalizować czasowo z $\mathcal{O}(n^3)$ do  $\mathcal{O}(n)$.\\
\subsection{Treść}
\paragraph{Zadanie 1} Należy stworzyć funkcję rozwiązującą układ $Ax=b$ metodą eliminacji Gaussa uwzględniającą postać macierzy A zadanej w streszczeniu dla dwóch wariantów \\ (a)bez wyboru elementu głównego \\(b)z częściowym wyborem elementu głównego\\ \paragraph{Zadanie 2} Należy napisać funkcję wyznaczającą rozkład $LU$ macierzy A metodą eliminacji Gauss'a uwzględniającą specyficzną postać macierzy $A$ dla \\ (a)bez wyboru elementu głównego \\(b)z częściowym wyborem elementu głównego \\ \paragraph{Zadanie 3} Należy napisać funkcję rozwiązującą układ równań $Ax=b$ ( uwzgledniającą specyficzną postać macierzy $A$ ).\\
\bigskip
Wszystkie funkcje powinny byc umieszczone w module o nazwie blocksys. Należy przeczytać Sparse Arrays manual Julia. Założyć, że dostęp do elementu macierzy jest w czasie stałym. Nie można używać $x=\dfrac{A}{b}$ oraz $lu$ z modułu LinearAlgebra.
\section{Zadanie 1}
\subsection{Opis standardowej procedury wraz z analizą złożoności algorytmu}
\paragraph{Na czym polega metoda eliminacji Gauss'a?}
Metoda ta polega na sprowadzeniu układu równań( macierzy) do równoważnego układu z wykorzystaniem macierzy trójkątnej górnej,  następnie rozwiązaniu tego układu przy pomocy algorytmu podstawiania wstecz.
\paragraph{Na czym polega algorytm podstawiania wstecz?}
Algorytm ten bazuje na zerowaniu kolejnych elementów macierzy poniżej diagonali( czyli tej niezerowej przekątnej).
\paragraph{Przebieg procedury}  1. Zerowanie elementów poniżej pierwszego wiersza w pierwszej kolumnie.\\2. Ogólnie, aby wyzerować $a_{i1}$ od wiersza i-tego odejmowany jest wyraz pierwszy pomnżony przez liczbę $\dfrac{a_{i1}}{a_{11}}$ \\ 3. Następnie przechodzimy do kolejnej kolumny( tutaj drugiej itd) i powtarzamy powyższe procedury z taką zmianą, że teraz odejmowany wiersz i( tutaj drugi $a_{22}$ itd).\\
Niestety procedura nie zadziała jeśli którtkolwiek z diagonalnych elementów będzie zerem( jak widać we wzorze). Aby rozwiązać ten problem należy przeprowadzić odpowiednią modyfikację. W i-tym kroku , w i-tej kolumnie należy wyszukać w kolejnych wierszach j-ty element o wartości co do modułu największej i zamienić wtedy $a_{ii}$ z $ a_{ji}$ (wzór: $a_{wierszkolumna}$).\\Następnie korzystamy z algorytmu wstecz, czyli matematycznie wzoru: $x_i = \dfrac{b_i-\sum^n_{j=i+1} a_{ij}}{a_{ii}}$.\\ 
Począwszy od ostatniego indeksu.( n)\\
Zakładając, że n jest rozmiarem macierzy złożonośc obliczeniowa eliminacji Gaussa wynosi co najwyżej $\mathcal{O}(n^3)$, a algorytm podstawiania wstecz $\mathcal{O}(n^2)$. Łącznie, aby rowiązać układ należy wykonać $\mathcal{O}(n^3)$ operacji.
\subsection{Opis implementacji wraz z analizą złożoności algorytmu}
\subsubsection{SparseMatrix pamięć}
Celem zadania jest modyfikacja i optymalizacja algorytmu. Zauważmy, że rozpatrywana macierz ma dość specyficzną, nietypową postać. Jest macierzą rzadką. Ma $(l+3)n-3l$ elementów, które nie są zerami.\\
\begin{center}
$l^2$ - w każdym z v bloków $A_k$, \\ $2l$ - w każdym z v-1 bloków $B_k$, \\ $l$ - w każdym z v-1 bloków $C_k$\end{center} Do przechowywania macierzy wykorzystamy struktuę do przechowywania macierzy rzadkich SparseMatrixCSC. Macierze takie są przechowywane w skompresowanym porządku kolumnowym. Algorytm Gauss'a natomiast ma przebieg wierszowy, zatem w implementacji musimy zamienić miejscami indeksy kolumny i wiersza i pracować na macierzach trasnponowanych. Aby ułatwić proces zrozumienia algorytmu uznaję to za problem implementacyjny i indeksuję w roważaniach w sposób standardowy. \underline{Dzięku użyciu takiej struktury mamy szybszy dostęp do elementów.}
\subsubsection{Modyfikacja, optymalizacja algorytmu}
Zwrócmy uwagę na postać macierzy A. Jest to macierz diagonalna, a nawet trójdiagonalna. W dodatku jest to macierz blokowa( $A_k,B_k,C_k$). Zauważmy, że nie jest konieczne zerowanie wszystkich elementów poniżej diagonali( przekątnej), bo już są wyzerowane. \\ \underline{Pozwala to zredukować ilość wykonywanych obliczeń.}\\ 
\paragraph{Indeks rzędu ostatniego niezerowego elementu w kolumnie} W pierwszych $l-2$ kolumnach potencjalne niezerowe elementy znajdują sie w $l$-pierwszych rzędach i są to elementy bloku $A_1$, dla kolejnych $l$ kolumn elementy niezerowe znajdują się prawdopodobnie w pierwszych $2l$ rzędach są to elementy bloku $A_3$ oraz dwie ostatnie kolumny bloku $B_2$. W kolejnych l kolumnach niezerowe elementy znajdują się w peirwszych 3l rzędach są nimi elementy bloku $B_3$ oraz elementy bloku $A_4$ rzecz jasna niezerowe elementy.\\
Zatem ostatni niezerowy element w danej kolumnie można obliczyć korzystając z funkcji min(). Ostatecznie ostatni niezerowy element w kolumnie wyrażamy wzorem: $ lastNotZeroInColumn(column) = min \Big( n,$ $l+l \Big \lfloor \dfrac{column+1}{l} \Big \rfloor \Big)$
\paragraph{Indeks kolumny ostatniego niezerowego elementu w rzędzie} 
Zwróćmy teraz uwagę na wiersze. W każdym wierszu ostatnim elementem niezerowmy jest element diagonali bloku $C$. Poza pierwszym wierszem, każdy z tych elementów jest oddalony równo o $l$ od elementów całej macierzy. W ostatnich rzędach ostatnie niezerowe elementy to po prostu elementy ostatniego bloku $A_v$ leżące pod indeksem $n$. \\Ostatecznie ostatni niezerowy element w rzędzie to:
$$lastNotZeroInRow(row) = min(n, row+l)$$ \\
Znając indeksy ostatniego niezerwowego elementu w rzędzie i kolumnie wiemy, do jakiego miejsca jest sens wykonywać obliczenia. Pozwala to znacznie przyspieszyć proces obliczania.\\
Metoda eliminacji Gauss'a doprowadza nas do macierzy trójkątnej górnej, który rowiązujemy przy pomocy algorytmu podstawiania wstecz. Mimo dotychczasowych usprawnień zauważyłem również, że wciąż algorytm można usprawnić. Algorytm eliminacji Gaussa przecież nie dostawia elementów niezerowych do danej macierzy( Poza elementami pod diagonalą bloków C). Zatem można skorzystać z wzoru na  $lastNotZeroInRow$ i sumować elementy tylko do określonego indeksu.
\subsubsection{Analiza złożoności obliczeniowej zmodyfikowanego algorytmu}
Zakładam, że l jest stałą. \\
Zewnętrzna pętla i eliminacji Gauss'a  wykonuje n-1 przejść, wewnętrzna j wykonuje dokładnie 2l przebiegów, a najbardziej wewnętrzna k i nie mająca w sobie żadnego innego zagnieżdżenia l opracji. Zewnętrzna pętla podstawiania wykonuje n przejść, a wewnętrzna co najwyżej l. W sumie łącznie dla eliminacji mamy $2l^2n$ operacji, a dla podstawiania $nl$, zatem złożoność wynosi $\mathcal{O}(n)$ nazywana złożonością liniową.
\subsection{Algorytm z częśćiowym wyborem elementu głownego rozwiązanie problemu zerowego elementu diagonali}
Jak już wspomnieliśmy w paragrafie \textsl{Przebieg procedury} na początku sekcji \textsl{2.1 Opis standardowej procedury wraz z analizą złożoności algorytmu} możemy napotkać na sytuację, w której nasz algorytm nie zadziała. Mianowicie, gdy którykolwiek z elementów diagonali będzie zerem. Na szczęście problem ten można rozwiązać w dość prosty sposób rozwiązać. W każdej kolumnie przed rozpoczęciem zerowania wybrać maksymalny co do wartości bezwzględnej element w kolumnie i uznać go za element, od którego będziemy odejmować.
\paragraph{Jak wyglądają modyfikacje wynikające z częściowego wyboru elementu głownego?}
Zacznijmy od analizy kolumny. Samo ograniczenie ostatniego, maksymalnego niezerowego argumentu w danej kolumie się nie zmieni, natomiast wartość podlega wątpliwości. W wyniku zamiany rzędami argumentu leżacego wyżej z leżącym niżej i kolejnym odejmowaniu go od wierszy poniższych możemy napotkać się na sytuację, w której program wypełni zerowy argument. Granicznym przypadkiem jest oczywiście zamiana i-tego wiersza z wierszem ostatnim( niezerowym),zatem wzór na ostatni niezerwoy element w danej kolumnie należy zmienić, tzn: $$ lastNonZeroInRow(lastNonZeroInColumn(row))= min(lastNonZeroInColumn(row)+l,n) =
$$
$$ = min(min \Big( n, l+l \Big \lfloor \dfrac{row+1}{l} \Big \rfloor \Big) +l,n) = min \Big( n, \underline{2l}+l \Big \lfloor \dfrac{row+1}{l} \Big \rfloor \Big) $$
Ostatecznie teraz indeks kolumny ostatniego niezerowego elementu w wierszu wyznaczamy wzorem : $$min \Big( n, \underline{2l}+l \Big \lfloor \dfrac{row+1}{l} \Big \rfloor \Big)$$ można je uznać za górne ograniczenie, czyli max indeks kolumny w row-wym wierszy \textsl{po przepermutowaniu}.
W celu uniknięcia nadużycia zasobów pamięci wykorzystam addytywną tablicę permutacji, zawierjącą indeksy kolejnych wierszy macierz. Zamiana zatem wykonywana jest na kopii, polega na odwołaniu się do tablicy permutacji np pod indeksem row będzie leżał row-ty wiersz z macierzy. 
\subsection{Analiza złożoności obliczeniowej zmodyfikowanego algorytmu z częściowym wyborem elementu głownego}
Wariant ten jest nieco bardziej kosztowany. Pojawia się koszt wyszukania maksymalnego elementu głownego o największej co do wartości bezwzględnej wartości w danej "zerowanej", bieżącej kolumnie. Wyszukanie go występuje w $lastNotZeroInColumn - i$ elementów, w przybliżeniu uznaję za $2l$.Wewnętrzna pętla przechodzi po $3l$ elementów każdego z wierszy. Ostatecznie koszt to $n2l(2l+3l)=10l^2n$, zatem jest około 5 razy bardziej złożony obliczeniowo niż algorytm bez wyboru elementu głownego. Mimo to algorytm jest wciąż asymptotycznie liniowy $
\mathcal{O}(n)$
\subsection{Wyniki eksperymentów porównujących zaimplementowane algorytmy dla danych testowych( tabele, wykresy) oraz interpretacja}
\subsection{Wnioski}
\end{flushleft}
\end{document}